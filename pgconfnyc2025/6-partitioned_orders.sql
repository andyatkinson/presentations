set role postgres;
SET search_path = pgconf, public;

-- NOTE: As a partitioned table, using a composite primary key
CREATE TABLE IF NOT EXISTS orders_partitioned (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  supplier_id BIGINT NOT NULL, -- Skipping FK for example simplicity here
  customer_id BIGINT NOT NULL, -- Skipping FK here
  quantity INT NOT NULL,
  PRIMARY KEY (supplier_id, id)
) PARTITION BY LIST (supplier_id);

CREATE TABLE orders_supplier_1 PARTITION OF orders_partitioned
    FOR VALUES IN (1);

CREATE TABLE orders_supplier_2 PARTITION OF orders_partitioned
    FOR VALUES IN (2);

CREATE TABLE orders_supplier_3 PARTITION OF orders_partitioned
    FOR VALUES IN (3);

CREATE TABLE orders_supplier_4 PARTITION OF orders_partitioned
    FOR VALUES IN (4);

CREATE TABLE orders_default PARTITION OF orders_partitioned
    DEFAULT;

\d+ orders_partitioned



--
-- INSERT and distribute roughly evenly among the partitions
-- Make sure schema search path includes "pgconf"
--
WITH supplier_list AS (
  SELECT id, row_number() OVER () - 1 AS rn
  FROM suppliers
),
customer_list AS (
  SELECT id, row_number() OVER () - 1 AS rn
  FROM customers
)
INSERT INTO orders_partitioned (supplier_id, customer_id, quantity)
SELECT
  s.id,
  c.id,
  (1 + random() * 10)::int
FROM generate_series(1, 100000) g
JOIN supplier_list s ON s.rn = g % (SELECT count(*) FROM supplier_list)
JOIN customer_list c ON c.rn = (g * 37) % (SELECT count(*) FROM customer_list);

-- Count the distribution of orders in partitions
SELECT
    count(*) AS count_all_partitions,
    count(*) FILTER (WHERE supplier_id = 1) AS count_supplier_1,
    count(*) FILTER (WHERE supplier_id = 2) AS count_supplier_2,
    count(*) FILTER (WHERE supplier_id = 3) AS count_supplier_3,
    count(*) FILTER (WHERE supplier_id = 4) AS count_supplier_4,
    count(*) FILTER (WHERE supplier_id NOT IN (1, 2, 3, 4)) AS no_supplier
FROM
    orders_partitioned;

-- Performance advantage: partition pruning
-- As long as WHERE clause includes partition information
-- e.g. WHERE supplier_id = 2;
show enable_partition_pruning;

-- Performance advantage is to include supplier_id in the WHERE clause
-- Then Postgres can query only the specific partition that contains that supplier data
-- Will scan only the relevant partition Seq Scan on "orders_supplier_1" of table "orders_partitioned"
EXPLAIN ANALYZE SELECT customer_id FROM orders_partitioned WHERE supplier_id = 2;

\d orders_supplier_2



-- Detachment
-- First, we have to drop the default partition
DROP TABLE orders_default;

-- Now we can detach the partition
ALTER TABLE orders_partitioned DETACH PARTITION orders_supplier_4 CONCURRENTLY;

-- \d+ orders_partitioned -- no longer see child table
\d orders_supplier_4;
-- We can then archive the data (pg_dump etc.) and then drop it
